Snippers-) acts,


Para crear el poyecto, ng init nombre.
borramos el HTML y copiamos lo del curso, una vez hecho creamos una carpeta llamada todos(dentro de app).
Creamos componentes. Nos vamos a todos y ponemos ng g m todos/todo --flat    (lo creamos en todos,llamado todo y --flat para que se quede ahi,en esa direccion)
Se creara un todo.nodule.ts
En app.module.ts, debemos importar dicho todo creado,tanto arriba como en medio.
creamos los otros modulos:
 ng g c footer --skipTests  (c de component)
 Ahora crearemos los diferentes todos dentro de la carpeta todo(todo lo relacionado con los todos)
  ng g c todos/todo-add (para la parte de arriba de añadir)
  ng g c todos/todo-footer(sera para los botones que hay debajo del cuerpo)
  ng g c todos/todo-item
  ng g c todos/todo-list (nos agrupara todos los item)
  Por ultimo creamos el componente principal:
    El controlador:
    ng g c todos/todo-page

Cogemos todo el html y lo pasamos a otra pagina. vamos a colocar cada cosa en su sitio.
Empezamos con footer. Copiamos la parte del html del footer y la pegamos en footer.component.html
para sacar modulos y que se vea fuera debemos exportarlos en su correspondiente ts. para usar por ejemplo el todopagecomponent, debemos exportarlo en
todo.module.ts
Es decir, como estamos poniendo el modulo de todo-page-component en app.component.html, debemos exportarlo de su lugar. Exportarlo en su contralador
que en este caso es el todo.module.ts Como hemos puesto todo el html dentro de todo-page-component(recuerda que dividimos el html en dos partes,footer y todo lo demas 
lo pusimos en todo-page) no hace falta exportar ninguno más. Si lo hubieramos dividido mas(el html) habría que exportar lo que quedase

Si nos fijamos, vemos que la parte del header, es la que corresponderia a todo-add, entonces borramos ese html, y lo cpiamos en el html de todo-add. Susdtituyendolo por el
nombre del componente de todo-add(<app-todo-add>)

Ahora creamos una carpeta llamada models,dentro creamos un archivo llamado todo.model.ts y dentro creamos la clase todo con sus propiedades(las que necesitemos)
Implementamos NGRX
npm install @ngrx/store --save
Creamos todo-actions dentro de la carpeta todos
Vamos a exportar el modulo del store. Vamos al app.module.ts. Y hacemos lo de la gui,a lo importamos arriba y en el medio(como lo pone la guia)
Ahora instalamos las devtools --- npm install @ngrx/store-devtools --save  y seguimos las intrucciones de la guia
Toca definir appState. Creamos un archivo llamado app.reducer.ts(el reducer general)
Agregar un todo(con formularios):
El lo hace con ReactiveFormsModule(lo importa primero en app.module). Lo importamos en app.module.ts y en todo.module.ts, para que llegue a los todos
Nos fijamos donde escribimos para añadir el todo, con lo que nos vamos al html de todo-add y abrimos su component.ts:
    añadimos un formcontrol  txtinput: FormControl
    constructor(){
        this.txtinput = new FormControl('Hola', Validators.required);//añadimos esto a la caja de texto que sera donde vayamos añadiendo todos
      }
    
        ngOnInit(): void {
            
        }
        Ahora añadimos ese txtinput a la caja de texto donde iremos añadiendo los todos:
        [formControl]="txtinput" (esto se lo añadimos como atributo, alado de class)
        para añadir la accion,añadimos abajo de formControl la accion:
            (keyup.enter)="agregar()" ---) cuando apretemos enter hacemos la funcion agregar.

        Añadimos el Store como siempre,dentro del constructor

Listar todos:
 ¿ Donde vamos a listarlo?? en todo-list. No añadimos ninguna acción puesto que queremos listar los todos conforme los añadamos.
 Creamos la clase en todo-list.component.ts, con un suscribe. ponemos un select('todos')para especificar que solo trabajamos con eso
 Luego añadimos la lista en el html con un ngfor dentro de la etiqueta

Controlar los todo:
En este caso queremos enviar el todo,con lo uqe dentro de la etiqueta de app-todo-item ponemos:
        *ngfor="let todo of todos"
        [todo]="todo" --) esta linea la añadimos. Seguidamente hacemos input en todo-item.component.ts para recibir el todo
        Añadimos dos propiedades al todo-item component el chkcompletado y el input. EL primero será el que controle el click verde y el segundo el todo
        Ahora vamos a establecer el foco cuando hagamos click(así cada vez que hacemos click,se pone editar solo ese input, y cuando hago click a otro, el primero se va)
        Ponemos una referencia algo como #inputfisico ( se le llama referencia local en angular), 
        Ahora en el componente usamos el VewChild:
            @ViewChild('inputFisico') txtInputFisico!: ElementRef;   ---) hacemos view al inputfisico creado como referencia local
        Ahora en vez de poner dblclick=editando, creamos un metodo llamado editar
        Para quitar  el foco cuando apretemos otro input---) blur (lo añadimos en el html y ponemos un metodo). con un simple metodo que diga:
          this.editando=false;
        Vamos a controlar el check(boton) para ellonos suscribrimoscon el chkcompletado
        Como es una accion,creamos la accion en todo.actions

Editar una tarea por hacer:
        Creamos la accion editar en todo.action
        La accion editar, la activaremos cuando acabamoe la edicion(terminarEdicion()). Realmente la accion editar es actualizar el antiguo texto
        con el nuevo introducido
        Si nos fijamos hemos puesto varias cosas. Dos validaciones, una de ellas indica que si no metemos ningun dato(borramos y salimos de la edicion)
        devuelve el texto que había. Otra importante es que cuando abrimos la edicion, seguimos viendo la infomacion, esto lo hacemos desde el metodo editar de todo-item-component

Borrar una tarea de una lista:

        1)Creamos la accion en todo.actions
        2)La implementamos en el reducer. Usamos el filter:
        on(actions.borrar,(state, {id})=> state.filter(todo=>todo.id !==id))  //decimos, regresa todos los todos donde el id sea distinto al id seleccionado
        3)Nos vamos al html, ponemos borrar y creamos su método en el todo-item-component

Marcar/desmarcar todos los todos:

        Hay en la derecha de donde añadimos todos, un boton. Queremos que cuando lo apretemos ,se marquen todos
        Creamos la accion, la metemos en el reducer(recordad que en el redcucer solo ponemos los elementos que vamos a querer y enviar. no la logica)
        Introducimos el metodo en el html
        Creamos el metodo en el componente(aqui si ponemos la logica, aqui cambiamos el completado,en el reducer solo le decimos que de todo, queremos el completado,aqui lo cambiamos)
Creamos nuevo Reducer para el filtro. El filtro es lo que nos dira en que boton de los de abajo estamos(todas,activos,completados)
He creado 2 snippers, reduc y acts. Uno para importar en actions y otro en reducer.
Creamos en el reducer los dos importes, creamos la funcion de estado inicial la constante de reducer __ y abajo exportamos la misma:

            const _filtroReducer = createReducer(estadoInicial,
              on(actions.setFiltro, (state, { filtro }) => estadoInicial),
            )




            export function filtroReducer(state: any, action: any) {
              return _filtroReducer(state, action);
            }

Combinar 2 o más reducer en el appState:

Creamos en app.reducer.ts una funcion(x x ejemplo) donde decimos que parte maneja cada reducer. Debemos añadirle las propiedades al appState que faltem
en este caso le añadimos el filtro, luego en appmodule, al tener ya una funcion que nos escoge el reducer segun que estemos manejando, sustituimos dentro del forRoot
{todos:todosReducer} por el nombre de la funcion x
Ahora vemos en redux(herramienta desarrollo) como hay dos arboles, uno de todos y otro de filtroReducer

Cambiar el filtro:
            Nos vamos al footer, que es donde tenemos los botones los cuales queremos filtrar:
            Aqui el problema es que no consigo cambiarlo. Creo que el error esta en filstro.reducer, ya que el escribe:
            on(setFiltro, (state, { filtro }) => filtro (con lo que le dice que el nuevo filtro sera el dado)
             y a mi solo me va con :
             on(setFiltro, (state, { filtro }) => estadoInicial en donde siempre devuelve el estado inicial(lo que le ponga arriba)

Conteo de tareas pendientes(queremos que salga el numero, conforme vayamos haciendo click)

Aplicar filtro visualmente:

            Debemos ir al todo-list.component(queremos hacerlo a traves de un pipe,ya que los pipes no mutan nada, lo cambian visualmente)
            En terminal : ng g pipe todos/filtro
            Cuidado, aquí al poner of y pasarle el filtro daba error. Hay que quitar el unknown del pipe y cambiarlo por any


Borrar TODOS LOS TODOS COMPLETADOS:
            Importante,poner la accion en todos, crearla,ponerla en el reducer y ahí mucho cuidado con map y filter
            Usamos map cuando queremos devolver todo el array pero con alguna funcion o algun cambio, cuando usamos
            filter, nos devolvera un array con los datos que cumpla la funcion(si quiero señalar todos pongo map)
            En este caso como quiero devolver un array con los NO COMPLETADOS, pongo un map(todo=> !todo.completado).


INGRESO /EGRESO APP :

Creamos una carpeta llamada ingreso/egreso en redux y ponemos ng new ingreso/egreso.
Creamos algun componente :
  ng g c auth/login --spec=false -is
  ng g c auth/register
  ng g c dashboard
  ng g c ingreso-egreso 
  ng g c ingreso-egreso/estadistica
  ng g c ingreso-egreso/detalle
  ng g c shared/footer
  ng g c shared/navbar
  ng g c shared/sidebar

  Configurar,copiamos los html de la carpeta descargada en los html creados con los componentes, vamos comprobando que funcionan los componentes. No olvidar
  si usamos bootstrap o css especial, ponerlo en en angular.json,en styles

  Creamo el app-routing.module.ts(ya lo tenia creado)
  una vez creamos el archivo(esta creado ya) de app-routing.module, añadimos las rutas, una de ingresar otro de registro,otra a dashboard que es la 
  que carga una vez paasamos el registro/inicio sesion y ponemos una mas para que cualquier otra ruta nos lleve de nuevo al dashboard.
  Debemos exportar la funcion de abajo del archivo routing al app.module.ts para que disponga de las rutas. Despues debemos poner la etiqueta de
  <router-outlet> en el html para que funcione las rutas
  Comprobamos poniendo localhost:4200/login que va, con register tambien y si ponemos cualquier otra cosa nos lleva a dasboard(this works!)
  para que un enlace redirija a un sitio(en login,para que ¿Quiere crear una nueva cuenta? nos lleve a register) ponemos esto en la etiqueta de html
  de crear una cuenta: routerlink="/register"
  En register lo mismo
  Ahora ya no necesitamos poner <app-login></app-login>, <app-register></app-register> en app.component.html
  Ahora debemos mostar detalle,estadistica ingreso-egreso en el dashboard. Para ello nos vamos al dasboard.html y ponemos la estrucutra:
  <app-navbar></app-navbar>


  <div class="page-body-wrapper">
    <app-sidebar></app-sidebar>
    <div class="main-panel">
      <div class="content-wrapper">
        //holaaa
      </div>
      <app-footer></app-footer>
    </div>
  </div>

  En hollas le metemos un router-outlet de nuevo
  Creamos un archivo en dasboard llamado dasboard.routes.ts para indicar las rutas que van a funcionar en el dashboard
  Igual que en la srutas anteriores  vamos añadiendo las rutas de este modo:
            declaramos:
            {path: 'detalle', component: DetalleComponent} indicando el nombre del componente(creado al principio)

  Ahora cogemos esta última funcion creada y la cambiamos en el archivo de app-routing.module.ts añadiendo un children par aindicarle que 
  va a recibir rutas tambien:
            añadimos children: dashboardRoutes

  Ahora funcionan las ruta tanto /login y /register como /estadistica /detalle /login/estadistica login/detalle
  Creamos las rutas para los botones(podemos poner directamente dondeu queramos la ruta /login)


HACER BACKUP DE LA APLICACIÓN:
git init
git add
git remote add origin (enlace)
git push -u master(la segunda vez sera solo git push)



Hacemos un releasetag para git:
            git tag -a v1.0.0 -m "template listo" ---) Con esto creamos un tag de forma local

            Ahora subimos los tags git push --tags

Ahora por mucho que actualicemos git hub, tenemos una copia de este momento de la aplicacion.


07-AUTENTICACION DE NUESTRA APLICACION LOGIN(NUEVA SECCION):

veremos:
            Firebase
            AngularFire2
            AngularFireAuth
            Backend y autorizaciones
            loginRegister
            Sweetalert
            Logout
            grabar un documento en Firebase
Empezamos con la comprobacion de que el botón de crear cuenta no se active hasta que no se rellene los campos. Usaremos formularios reactivos asi que 
los importamos al app.module.ts
Editamos el register.component.html añadiendo el fromGroup en el form y poniendo el nombre de la copia(en este caso registroForm)
Luego añadimos un formcontrolName dentro de los input en los que metemos los datos(para poder guardarlos) con el nombre que hayamos dado a cad aatributo en
en el component.ts(
nombre: ['',Validators.required],
correo: ['',Validators.required, Validators.email],
password: ['',Validators.required]
)
En este caso nombre,correo y password



Preparar base de datos:
  usaremos firebase.google.com
  Nos metemos, creamos cuenta,creamos proyecto
  Configuremos metodos de acceso en AUTENTICACION. Ponemos de momento correo electronico/contraseña ( esto es simplemente para permitir a la aplicacion entrar mediante corre/pasword)
  En data base usaremos el firestore beta
  Creamos la base de datos en modo privado(el primero) y lo dejamos así:
      //allow read, write: if false;  ---)ahora mismo lo tengo comentado, esto indica que deben estar autenticados para poder grabar
          allow read, write;  //con esto indico ahora que no tienes que estar autenticado para "grabar"(leer y escribir)

  COMUNICACION FIREBASE CON LA APLICACION:
    Instalamos angular fire:
    ng add @angular/fire ---) deberemos crear 3 archivos manualmente en una carpeta que tb crearemos llamda environment.
    Creamos environment.pord.ts,environment.stanging.ts,environment.ts
    Luego añadimos en angular.json :
    "fileReplacements": [
      {
        "replace": "apps/some-app/src/environments/environment.ts",
        "with": "apps/some-app/src/environments/environment.prod.ts"
      }
    ],
Y luego instalamos con ng add @angular/fire

CREAMOS PRIMER USUARIO:
    Ponemos un comando: ng g s services/auth
    Abrimos el archivo generado auth.service.ts 
    Creamos el método y lo inyectamos en el register.component.ts y ponemss:
       private authService: AuthService
    Importante importar el modulo tanto en auth como en register.component

  Ojo con los errores, puse login en vez de crearusuario y estuve horas buscando el problema. Luego las validaciones de firebase que he visto:
    correo debe ser sdsds@sdsd.com/es , pasword, 6 digitos. Si no pones eso a la hora de crear salen errores aparentemente gordos
  Una vz funciona, nos da el UID,identificador del usuario
  Ahora ya si vamos al firebase(la web) vemos todos los intentos que hemos hecho de autenticacion
  Ahora nos da error si creamos el mismo usuario tambien
  No olvidar cuando inyectamos el loginform, meterlo en el html,en el form
  No olvidar poner en el html, en cada input que necesitamos, ell formcontrolname
  No olvidar poner el boton type="submit " si estamos con formularios
  no olvidar meter el ngsubmit en el formulario, alado de formgroup. Estoy ahora mismo con login asi que le pongo ngSubmit="loginUsuario"(o el metodo que hayamos
  creado en el componente.ts)
  El comonente.ts manda directamente sobre el html

  SWEETALERT2 PARA LOS ERRORES:
  Vmos a editar los dsitintos errores, si ponemos mal el email,el nombre,correo
  Buscamos por google sweetalert2 y lo instalamos: npm install sweetalert2
  Cambiamos el que queremos por el console.error(erro) que teníamos
  Para que funcionase, tuve que meter en el html principal : 
  <script src="sweetalert2.min.js"></script>
  <link rel="stylesheet" href="sweetalert2.min.css">
  y hacer así la importacion


  CERRAR SESION:

  Creamos en auth.service un logout con su correspondiente return (this.auth.signOut());

  Buscamos el boton y nos vamos al html donde este. Ponemos el metodo y en el componente.ts  creamos el metodo.
  En este caso le ponemos un loading:
  cerrarSesion(){
    Swal.fire({
      title: 'Saliendo de tu cuenta',
      didOpen: ()=>{
        Swal.showLoading();
       
      }
    })
      this.authService.logOut()
      .then(()=>{
        this.route.navigate(["/login"])
        Swal.close();
      })
  }

}
No olvidar inyectar: private authService:AuthService,
                     private route: Router


  Obtener informacion del usuario(cuando se conecta,se desconecta..):

  Creamos un metodo en auth.service.ts: initAuthListener(){}
  OJO: la llamada ha de ponerse en el app.compontent.ts, ya que se registre,salga o inicie,siempre va a psar por el appcomponent
  Importante que al hacer logout, aparezca null en fuser

PROTEGER RUTAS(estar autenticados):

Esto es para asegurarse de las rutas, de estar identificado para poder acceder al sitio web
Creamos un guard     ng g guard services/auth ---) seleccionamos canActivate de momento
Vemos la configuracion del guard. Sirve para que la persona noi pueda entrar sin estar identificado
Debemos colocar este guard en el app-routing.module, y como queremos evitar que entren en el dashboard, lo ponemos ahí
Vemos que no funciona porque tenemos el return true,si ponemos el return false ya funciona(en auth.guard)pero si podemos ir al login,ya que
solo lo hemos añadido al dashboard

Ahora creamos un metodo en authservice lllamado isAuth()
import{map} from 'rxjs/operators';   Importamos esto porque nos permite coger un estado,mutarlo en lo que queramos,cambiarlo, lo que queramos.

Ahora dentro del isAuth(){
  return this.auth.authSttate.pipe(
    map(fbUser=>fbUser!=null)  ---) si existe,regresa un true, si no existe un false. Nos devuelve un Obersvable,asi que hay que ponerle que resuelve un boolean
  )
}
Este isAuth es lo que necesitamos llamar en auth.guard.ts
Hemos añadido un tap, un efecto secundario que lo que hace es que si damos true o false ,hacemos algo. En este caso, si no estamos autenticados, en vez
de dejar la hoja en blanco, nos envía a login
Entre otras cosas, si cerramos sesion y damos atras(para entrar en el dashboard), vemos que no nos deja


CREAR DOCUMENTO DE BASE DE DATOS POR CADA USUARIO:
 PAra tener algo de informacion en firebase sobre el uid,y datos del usuarioS. Crearemos  un documento con email nombre y uid de cada usuario
 Creamos un modelo para el usuario, dentro de la carpeta models(la creamos si no) creamo el archivo usuario.model.ts
 Le ponemos los atributos que queremos ver, en este caso nombre,email y uid
 Pensamos donde ponerlo, y decidimos en crear usuario, ya que es donde nos esta pidiendo los 3 datos
 Como es una promesa podemos poner el .then y añadimos la accion de crear usuario con una const :
  const newUser= new Usuario(user.uid,nombre,user.email) . Lo hemos puesto cuando se crea un usuario(ya que si se crea es que los datos son validos)entonces
  podemos coger el nombre y email directamente de los atributos de arriba(nombre,email), o ir al user(user.nombre,user.email)El uid solo podremos mediante user.uid
  ya que en crearusuario(a,b,c) ninguno de los atributos es el uid

Inyectamos el firestore,en el constructor y luego hacemos la llamada dentro del .then
En este caso se llama solo Firestore(lo comprobe porque puse AngularFirestore y me salia que no aparecia,busque en @angular/firestore y vi como se llamab)
Siempre que haya una promesa podemos poner el .then .catch  y siempre hay que poner un return
Ahora ya tenemos listo nuestro registro y podemos trabajar con el numero de usuarios que queramos


08-REDUX EN NUESTRA APLICACION DE INGRESO / EGRESO


  1) Crearemos nuestro primer reducer y acciones para controlar el estado de la aplicacion
  2) ActionReducerMap
  3) Dispach de acciones de UID
  4) Acciones de Auth
